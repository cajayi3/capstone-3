type Coords = {
    lat: number;
    lng: number;
};

type DateLike = Date | string | number;
type Datey = Date | string;
/**
 * @example "2021-01-01T00:00:00.000Z"
 */
type ISODate = string;
/**
 * @example "2021-01-01"
 */
type ISODay = string;
/**
 * @example "2021-01"
 */
type ISOMonth = string;
/**
 * @example "2021"
 */
type ISOYear = string;
/**
 * @example "America/New_York"
 */
type Timezone = string;
type DateRange<T extends DateLike = DateLike> = {
    startDate: T;
    endDate: T;
};
type DateSeries<T extends DateLike = DateLike> = T[];

/**
 * Makes all keys required and removes undefined and null from the value types.
 * @example
 * type Example = {
 *  a: string;
 *  b: string | undefined;
 *  c?: string;
 *  d?: number | null;
 * };
 * type Result = Defined<Example>;
 * {
 *  a: string,
 *  b: string,
 *  c: string,
 *  d: number
 * }
 */
type Defined<T> = {
    [P in keyof T]-?: NonNullable<T[P]>;
};

type Dimensions = {
    width: number;
    height: number;
};

type VoidFn = () => void;
declare const noop: VoidFn;

type Key = string | number | symbol;
type PlainKey = string | number;
type ObjectKey<T> = keyof T;
type ObjectKeys<T> = ObjectKey<T>[];
type ObjectValue<T> = T[keyof T];
type ObjectValues<T> = ObjectValue<T>[];
type ObjectEntry<T> = {
    [K in keyof T]: [K, T[K]];
}[keyof T];
type ObjectEntries<T> = ObjectEntry<T>[];
/**
 * A plain object is an object that is not an array, does not have a length property, and is not a function.
 * Would have been nice to call it just Object, but that's already taken by the built-in type.
 */
type PlainObject<T = any> = Record<PlainKey, T> & {
    length?: never;
};

type HashMap<T = any> = Record<PlainKey, T>;
type NumberMap = Record<PlainKey, number>;
type StringMap = Record<PlainKey, string>;
type BoolMap = Record<PlainKey, boolean>;
type TrueMap = Record<PlainKey, true>;

type Matrix<T> = T[][];

type Maybe<T> = T | null | undefined;
type MaybePromise<T> = Maybe<Promise<T>>;
type MaybePromiseOrValue<T> = MaybePromise<T> | T;
type MaybePromiseOrValueArray<T> = MaybePromiseOrValue<T>[];

type NonUndefined<T> = T extends undefined ? never : T;

/**
 * Makes picked keys required and defined.
 * @example
 * type Example = {
 *  a: string;
 *  b: string | undefined;
 *  c?: string;
 *  d?: number | null;
 * };
 * type Result = PickDefined<Example, "a" | "b" | "d">;
 * {
 *  a: string;
 *  b: string | undefined;
 *  d: number | null;
 * }
 */
type PickDefined<T, K extends keyof T> = Pick<Defined<T>, K>;

/**
 * Makes picked keys required. (does not remove undefined and null from the value types)
 * @example
 * type Example = {
 *  a: string;
 *  b: string | undefined;
 *  c?: string;
 *  d?: number | null;
 * };
 * type Result = PickRequired<Example, "a" | "b" | "d">;
 * {
 *  a: string;
 *  b: string | undefined;
 *  d: number | null;
 * }
 */
type PickRequired<T, K extends keyof T> = Pick<Required<T>, K>;

type Point = {
    x: number;
    y: number;
};

type PrismaSelect<T> = Record<keyof T, true>;

type Serialized<T> = T extends Date ? string : T extends Array<infer R> ? Array<Serialized<R>> : T extends object ? {
    [K in keyof T]: Serialized<T[K]>;
} : T;

/**
 *
 * @description Generate a series of dates between the start and end dates
 * NOTE: it does NOT include the end date
 */
declare const getDateRangeSeries: (dateRange: DateRange, unit: "day" | "hour" | "minute" | "second" | "calendarMonth") => ISODate[];

/**
 *
 * @deprecated use getDateRangeSeries instead
 */
declare const getDateSeries: (startDate: Date, endDate: Date, unit: "days" | "hours" | "minutes" | "seconds") => ISODate[];

/**
 * @description Returns the smallest and biggest dates from an array of dates in DateRange format
 * @param dates - Array of dates to find the range for
 * @returns DateRange object with startDate (smallest) and endDate (biggest)
 * @throws Error if the array is empty or contains invalid dates
 */
declare const getDateSeriesRange: (dateSeries: DateSeries<DateLike>) => DateRange;

declare const isOver18: (birthDate: DateLike) => boolean;

/**
 * Note: This function does not use defaults, use startOfToday instead.
 *
 * @param day - The date to get the start of the day for.
 * @returns A new Date object set to the start of the day.
 */
declare const startOfDay: (day: Date) => Date;

declare const startOfNextMonth: () => Date;

declare const startOfNextWeek: () => Date;

declare const startOfThisWeek: () => Date;

declare const startOfToday: () => Date;

declare const startOfTomorrow: () => Date;

declare const startOfUTCDay: (date: Date) => Date;

/**
 * Returns the start of tomorrow (00:00:00.000) in UTC time.
 *
 * @param date - The date to calculate tomorrow from. Defaults to current date if not provided.
 * @returns A new Date object set to the start of tomorrow in UTC time.
 */
declare const startOfUTCTomorrow: () => Date;

declare const formatCamelCase: (str: string) => string;

/**
 *
 * @example formatCookies({}) => ""
 * @example formatCookies({ session: "123", _ga: 123 }) => "session=123; _ga=123;"
 */
declare const formatCookies: (object: PlainObject) => string;

/**
 *
 * @example formatIndexProgress(-1, 10) => [1/10] capped
 * @example formatProgress(1, 10) => [2/10]
 * @example formatProgress(11, 10) => [10/10] capped
 */
declare const formatIndexProgress: (index: number, total: number) => string;

/**
 *
 * @example formatNumber(1000, { compact: true }) // 1K
 * @example formatNumber(1111, { maxDigits: 2 }) // 1,100
 * @example formatNumber(111111.123123123) // 111,111.123
 * @example formatNumber(0.12345, { percentage: true, maxDigits: 2 }) // '12.35%' (rounding)
 */
declare const formatNumber: (value: number, { compact, maxDigits, percentage, }?: {
    compact?: boolean | undefined;
    maxDigits?: number | undefined;
    percentage?: boolean | undefined;
}) => string;

/**
 *
 * @example formatPercentage(1) => 100%
 * @example formatPercentage(0, { digits: 2 }) => 0.00%
 */
declare const formatPercentage: (value: number, { digits, }?: {
    digits?: number | undefined;
}) => string;

/**
 * @deprecated Use `formatIndexProgress` instead.
 */
declare const formatProgress: ({ index, total, }: {
    index: number;
    total: number;
}) => string;

declare const stringToCSSUnicode: (text: string) => string;

declare const stringToUnicode: (text: string) => string;

declare const array: <U extends (...args: any) => any>(length: number, mapFn?: U) => ReturnType<U>[];

/**
 * Given 2 arrays, returns the (unique) elements that belong to each but not both at the same time.
 * @example
 * arrayDiff([1, 2, 3], [2, 3, 4]); // [1, 4]
 */
declare const arrayDiff: (arr1: any[], arr2: any[]) => any[];

/**
 * @description Given 2 arrays, returns the (unique) elements that belong to both arrays.
 * @example
 * arrayIntersection([1, 2, 3], [2, 3, 4]); // [2, 3]
 */
declare const arrayIntersection: <T>(arr1: T[], arr2: T[]) => T[];

declare const capitalize: (string: string) => string;

declare const chunkArray: <T>(array: T[], size: number) => T[][];

declare const chunkedAll: <T>(array: T[], chunkSize: number, fn: (chunk: T[]) => Promise<any>) => Promise<any[]>;

/**
 * @description Run a series of (async) functions in order and return the results
 * @param array
 * @param chunkSize
 * @param fn
 * @param options.minChunkTimeMs - Minimum time to process each chunk
 */
declare const chunkedAsync: <T>(array: T[], chunkSize: number, fn: (chunk: T[], chunkIndex: number, chunks: T[][]) => Promise<any>, { minChunkTimeMs, }?: {
    minChunkTimeMs?: number | undefined;
}) => Promise<any[]>;

/**
 * @description Run a series of (async) functions with dynamic chunk sizes
 * @param array - Array to chunk
 * @param initialChunkSize - Size of initial chunk
 * @param fn - Function to run on each chunk
 * @param options.idealChunkDuration - Ideal time to process each chunk, the chunk size will adjust to meet this duration
 * @param options.maxChunkSize - Maximum chunk size (default 200)
 * @param options.minChunkDuration - Minimum time to process each chunk (useful for rate limiting)
 * @param options.minChunkSize - Minimum chunk size (default 1)
 * @param options.sleepTimeMs - Time to sleep between each chunk
 */
declare const chunkedDynamic: <T>(array: T[], initialChunkSize: number, fn: (chunk: T[], currentChunkIndex: number) => Promise<any>, { idealChunkDuration, maxChunkSize, minChunkDuration, minChunkSize, sleepTimeMs, }?: {
    idealChunkDuration?: number | undefined;
    maxChunkSize?: number | undefined;
    minChunkDuration?: number | undefined;
    minChunkSize?: number | undefined;
    sleepTimeMs?: number | undefined;
}) => Promise<any[]>;

declare const clamp: ({ number, min, max, }: {
    number: number;
    min: number;
    max: number;
}) => number;

declare const cleanSpaces: (str: string) => string;

/**
 * @returns element from array at index, if index is greater than array length, it will loop back to the start of the array
 */
declare const cyclicalItem: <T>(array: T[], index: number) => T;

/**
 * Print or log helper that does not break on circular references, and expands nested objects.
 */
declare const dir: (arg: any, { maxDepth }?: {
    maxDepth?: number | undefined;
}) => void;

declare const enumKeys: <T extends object>(arg: T) => ObjectKeys<T>;

declare const enumValues: <T extends object>(enumObject: T) => ObjectValues<T>;

/**
 * @returns a string with only alphanumeric characters
 * @example filterAlphanumeric("!abc()") // returns "abc"
 */
declare const filterAlphanumeric: (string: string) => string;

declare const first: <T>(arr: T[]) => T;

declare const firstKey: <T extends PlainObject<any>>(arg: T) => keyof T;

declare const firstValue: <T extends PlainObject<any>>(arg: T) => ObjectValue<T>;

/**
 * Get a client cookie by name, works only in the browser
 * @param name
 * @returns the cookie value, if exists
 */
declare const getCookieByName: (name: string) => string | undefined;

declare const getKeys: {
    (o: object): string[];
    (o: {}): string[];
};

declare const getUrlSearchParam: (urlString: Maybe<string>, param: string) => string | undefined;

declare const getUrlSearchParams: (urlString: Maybe<string>) => Record<string, string>;

/**
 *
 * @param items
 * @param key
 * @returns Record<keyof T, T[]>
 * @example
 * const items = [
 *   { externalId: 1, value: 100 },
 *   { externalId: 1, value: 50 },
 *   { externalId: 2, value: 200 },
 *   { externalId: 2, value: 100 },
 *   { mis_spelled_externalId: 2, value: 90 }, // not included in any group
 * ];
 * const ordersByInstrument = groupByKey(items, "externalId");
 * // {
 * //   1: [
 * //     { externalId: 1, value: 100 },
 * //     { externalId: 1, value: 50 },
 * //   ],
 * //   2: [
 * //     { externalId: 2, value: 200 },
 * //     { externalId: 2, value: 100 },
 * //   ],
 * // }
 */
declare const groupByKey: <T, K extends keyof T>(items: T[], key: K) => Record<keyof T, T[]>;

declare const incrementalId: () => number;

declare const keysLength: <T extends PlainObject<any>>(obj: T) => number;

declare const last: <T>(arr: T[]) => T;

declare const lastIndex: (array: any[]) => number;

/**
 *
 * @description Given an array of objects, returns a record where the key is the value of the object's key
 * NOTE: if two objects have the same key, the last one will be the one kept.
 * Useful for quick lookups by key.
 * @example
 * const items = [{ id: 1, name: "Alice" }, { id: 2, name: "Bob" }];
 * const itemsById = mapByKey(items, "id");
 * itemsById[1]; // { id: 1, name: "Alice" }
 * itemsById[2]; // { id: 2, name: "Bob" }
 */
declare const mapByKey: <T extends PlainObject<any>>(items: T[], key: keyof T) => Record<Exclude<T[keyof T], null | undefined>, T>;

/**
 * @description Simple merge function that merges two objects, arrays get overwritten, no options
 *
 */
declare const merge: (target: PlainObject, source: PlainObject) => PlainObject<any>;

/**
 * @description Merge two arrays, unique values, no options
 * @example mergeArrays([1,2,3], [2,3,4]) => [1,2,3,4]
 */
declare const mergeArrays: (arrayA: any[], arrayB: any[]) => any[];

declare const moveToFirst: <T>(items: T[], condition: (item: T, i: number, items: T[]) => boolean) => T[];

declare const moveToLast: <T>(items: T[], condition: (item: T, i: number, items: T[]) => boolean) => T[];

declare const normalizeNumber: ({ value, max, min, }: {
    value: number;
    max: number;
    min: number;
}) => number;

declare const objectDiff: (leftObject: PlainObject, rightObject: PlainObject) => PlainObject<any>;

declare const omit: <T extends PlainObject<any>>(obj: T, keys: (keyof T)[]) => Partial<T>;

/**
 *
 * @param arg
 * @param options - asUTC: Use this when parsing an incomplete ISO date (e.g. "birth date") where timezone is irrelevant
 * @returns a JS Date object or undefined, by default parsed in local time for incomplete dates
 */
declare const parseDate: (arg?: Maybe<DateLike>, options?: {
    asUTC?: boolean;
}) => Date | undefined;

/**
 *
 * @description Given an object, returns a new object with only the keys that are in the `keys` array.
 * @example
 * const obj = { a: 1, b: 2, c: 3 };
 * pickObjectKeys(obj, ["a", "c"]); // { a: 1, c: 3 }
 */
declare const pickObjectKeys: <T extends PlainObject<any>>(obj: T, keys: ObjectKeys<T>) => Partial<T>;

/**
 *
 * @description Given an object, returns a new object with only the keys that have the values in the `values` array.
 * @example
 * const obj = { a: 1, b: 2, c: 3 };
 * pickObjectValues(obj, [1, 3]); // { a: 1, c: 3 }
 */
declare const pickObjectValues: <T extends PlainObject<any>>(obj: T, values: ObjectValues<T>) => Partial<T>;

declare const pluck: <T extends PlainObject<any>>(items: T[], key: keyof T) => Exclude<T[keyof T], null | undefined>[];

declare const promiseWithTimeout: <T>(promise: () => Promise<T>, timeoutMs: number, error?: Error) => Promise<T>;

declare const removeUndefinedValues: (obj: PlainObject) => {
    [k: string]: any;
};

declare const scrambleText: (str: string) => string;

/**
 * Serialize shallow object to a deterministic string,
 * for nested objects use [json-stable-stringify](https://www.npmjs.com/package/json-stable-stringify)
 *
 * @example
 * serialize({ b: 1, a: 2 }) // '{"a":1,"b":2}'
 */
declare const serialize: <T extends PlainObject<any>>(obj: T) => string;

type AsyncFunction<T = any> = () => Promise<T>;
type SeriesResult<T extends readonly AsyncFunction[]> = {
    [K in keyof T]: T[K] extends AsyncFunction<infer U> ? Awaited<U> : never;
};
/**
 *
 * @description Run a series of (async) functions in order and return the results
 * @example
 * const results = await seriesAsync([
 *  () => Promise.resolve(1),
 *  () => sleep(100).then(() => 2),
 *  () => Promise.resolve(3),
 *  async () => 4,
 * ]); => [1, 2, 3, 4]
 */
declare const seriesAsync: <T extends readonly AsyncFunction<any>[]>(series: readonly [...T]) => Promise<SeriesResult<T>>;

/**
 * Sets a value in an object using a dot-separated path.
 *
 * @param obj The object to set the value in.
 * @param path The path to the key to set, separated by dots.
 * @param value The value to set.
 */
declare const setObjectPath: (obj: PlainObject, path: string, value: any) => void;

declare const setUrlSearchParams: (currentURL: string, searchParams?: Record<string, Maybe<string | number | boolean | PlainObject>>) => string;

declare const shuffle: <T>(array: T[]) => T[];

declare const sleep: (timeMs: number) => Promise<void>;

declare const stringify: (arg?: any) => string;

declare const toggleArrayValue: <T>(array: T[], value: T) => T[];
/**
 * @deprecated Use toggleArrayValue instead
 * @param {T[]} array
 * @param {T} value
 * @returns {T[]}
 */
declare const toggleArray: <T>(array: T[], value: T) => T[];

declare const truncate: (arg: string, limit: number, { ellipsis, position, }?: {
    ellipsis?: string | undefined;
    position?: "start" | "middle" | "end" | undefined;
}) => string;

declare const uniqueValues: <T>(arr: T[]) => T[];

/**
 * Calculates the average of a list of numbers.
 * @example
 * average([1, 2, 3, 4, 5]); // 3
 * average(1, 2, 3, 4, 5); // 3
 */
declare const average: (numbers: number[]) => number;

declare const isBetween: (value: number, min: number, max: number) => boolean;

declare const isOutside: (value: number, min: number, max: number) => boolean;

declare const isStrictlyBetween: (value: number, min: number, max: number) => boolean;

/**
 * Returns the maximum value in an array of numbers.
 * @param values - The array of numbers to find the maximum value of.
 * @returns The maximum value in the array. If the array is empty, returns 0.
 */
declare const max: (values: number[]) => number;

declare const min: (values: number[]) => number;

declare const multiply: (numbers: number[]) => number;

/**
 * Normalises an array of numbers
 * @example normaliseArray([1, 2, 3]) => [0, 0.5, 1]
 */
declare const normaliseArray: (values: number[]) => number[];

/**
 *
 * @example normaliseNumber(50, 0, 100) => 0.5
 */
declare const normaliseNumber: (value: number, minValue: number, maxValue: number) => number;

/**
 *
 * @param previous Positive percentage i.e. 0.1 for 10%
 * @param current Positive percentage i.e. 0.2 for 20%
 * @returns
 */
declare const percentageChange: (previous: number, current: number) => number;

declare const sum: (numbers: number[]) => number;

declare const prismaDateRange: ({ startDate, endDate }: DateRange) => {
    gte: Date;
    lt: Date;
};

type RandomAddress = {
    city: string;
    country: string;
    countryCode: string;
    state?: string;
    street: string;
    line2?: string;
    number: string;
    zip: string;
};

declare const randomAddress: () => RandomAddress;

/**
 * Generates a random alphanumeric code that can be used for verification codes, etc.
 * Does not contain 0s or Os as they get confused with each other.
 * @param length The length of the code to generate.
 * @returns A random alphanumeric code.
 * @example
 * randomAlphaNumericCode(); => "A2G4G6"
 */
declare const randomAlphaNumericCode: ({ length, }?: {
    length?: number | undefined;
}) => string;

declare const randomArray: () => (string | number | boolean | symbol | Date | BigInt)[];

declare const randomArrayItem: <T>(array: T[], { weights }?: {
    weights?: number[] | undefined;
}) => T;

type BankAccount = {
    abaNumber?: string;
    accountHolderName: string;
    accountHolderType: "company" | "individual" | "other";
    accountNumber: string;
    accountType?: "checking" | "savings";
    bankName?: string;
    bsbNumber?: string;
    bankAddress?: string;
    bicSwift?: string;
    branchCode?: string;
    iban?: string;
    routingNumber?: string;
    institutionNumber?: string;
    branchTransitNumber?: string;
    sortCode?: string;
};

declare const randomBankAccount: () => BankAccount;

declare const randomBool: () => boolean;

declare const randomChar: () => string;

type Company = {
    name: string;
    vatRegNumber?: string;
};

declare const randomCompany: () => Company;

declare const randomCoords: () => Coords;
declare const randomLat: () => number;
declare const randomLng: () => number;

declare const randomDate: ({ startDate, endDate }?: Partial<DateRange>) => Date;
declare const randomMaxDate: ({ startDate, endDate }: Partial<DateRange>) => Date;
declare const randomFutureDate: ({ startDate, endDate, }?: Partial<DateRange>) => Date;
declare const randomPastDate: ({ startDate, endDate, }?: Partial<DateRange>) => Date;
declare const randomDateRange: () => {
    endDate: Date;
    startDate: Date;
};

declare const randomEmail: ({ handle, handleSuffix, }?: {
    handle?: string | undefined;
    handleSuffix?: string | undefined;
}) => string;

declare const randomEmoji: () => string;

declare const randomEmptyValue: () => number | null | undefined;

declare const randomEnumKey: <T extends object>(arg: T) => keyof T;

declare const randomEnumValue: <T extends object>(arg: T) => ObjectValue<T>;

declare const randomFile: ({ name, extension, }?: {
    name?: string | undefined;
    extension?: string | undefined;
}) => File | undefined;

declare const JS_MAX_DIGITS = 16;
declare const randomFloat: (min?: number, max?: number, decimals?: number) => number;

/**
 *
 * @returns a unique social-like handle
 * @example "john.doe15"
 */
declare const randomHandle: ({ suffix }?: {
    suffix?: string | undefined;
}) => string;

declare const randomHexColor: () => string;

declare const randomHexValue: () => string;

declare const randomHtmlColorName: () => string;

declare const randomIBAN: () => string;

declare const randomInt: ({ min, max, }?: {
    min?: number | undefined;
    max?: number | undefined;
}) => number;
declare const randomBigInt: () => BigInt;
declare const randomPositiveInt: ({ min, max, }?: {
    min?: number | undefined;
    max?: number | undefined;
}) => number;
declare const randomNegativeInt: ({ min, max, }?: {
    min?: number | undefined;
    max?: number | undefined;
}) => number;
declare const randomMaxSafeInt: () => number;
declare const randomMaxInt: () => number;
declare const randomFormattedPercentage: () => string;

declare const randomIP: () => string;

declare const randomName: () => string;
declare const randomFirstName: () => string;
declare const randomLastName: () => string;
declare const randomFullName: () => string;

/**
 * Generates a random numeric code that can be used for verification codes, etc.
 * Does not start with 0.
 * @param length The length of the code to generate.
 * @returns A random numeric code.
 * @example
 * randomNumericCode(); => "123456"
 * @example
 * randomNumericCode({ length: 4 }); => "1234"
 */
declare const randomNumericCode: ({ length }?: {
    length?: number | undefined;
}) => string;

declare const randomObject: ({ maxDepth, circular, }?: {
    maxDepth?: number | undefined;
    circular?: boolean | undefined;
}) => PlainObject<any>;

/**
 * Generates a random paragraph of text.
 * @param maxCharacters The maximum number of characters. The paragraph will be truncated to this length if it exceeds it. Default is 200.
 * @param words The number of words. Default is 8.
 * @returns A random paragraph of text.
 */
declare const randomParagraph: ({ maxCharacters, minWords, maxWords, }?: {
    maxCharacters?: number | undefined;
    minWords?: number | undefined;
    maxWords?: number | undefined;
}) => string;

declare const randomPassword: ({ minChars, maxChars, }?: {
    minChars?: number | undefined;
    maxChars?: number | undefined;
}) => string;

declare const randomPath: ({ depth, }?: {
    depth?: number | undefined;
}) => string;

declare const randomPhoneNumber: () => string;

declare const randomString: ({ length, }?: {
    length?: number | undefined;
}) => string;

declare const randomSymbol: () => symbol;

/**
 * This is a light-weight version of the `generateUuid` function
 * To be used only for test purposed and NOT for production
 * Leave 0s, so it gets immediately recognized as a fake uuid
 *
 * /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
 */
declare const randomUUID: () => string;

declare const randomValue: () => string | number | boolean | symbol | Date | BigInt;

declare const randomWord: () => string;
declare const randomNoun: () => string;
declare const randomVerb: () => string;

declare const formatTrpcInputQueryString: (input: PlainObject) => URLSearchParams;

declare const isArray: <T>(arg?: any) => arg is T[];

declare const isArrayIncluded: <T>(arr1: T[], arr2: T[]) => boolean;

declare const isBoolean: (arg: any) => arg is boolean;

declare const isBrowser: () => boolean;

declare const isBuffer: (val?: any) => boolean;

declare const isClient: () => boolean;

declare const isEmail: (arg: string) => boolean;

declare const isEmpty: (arg?: Maybe<any>) => boolean;
declare const isEmptyString: (arg: string) => boolean;
declare const isEmptyArray: (arg: any[]) => boolean;
declare const isEmptyObject: (arg: PlainObject) => boolean;

declare const isFile: (arg?: any) => arg is File;

/**
 * @returns true if the argument can be called like a function -> fn() or await fn()
 */
declare const isFunction: (arg: any) => arg is Function;

declare const isFutureDate: (arg: DateLike) => boolean;

declare const isJsDate: (arg: Date) => arg is Date;

declare const isKey: <T extends PlainObject<any>>(key: Key, obj: T) => key is keyof T;

declare const isLastIndex: (index: number, array: any[]) => boolean;

declare const isNotEmptyString: (arg: any) => boolean;

declare const isInt: (arg: any) => boolean;
declare const isEven: (arg: any) => boolean;
declare const isOdd: (arg: any) => boolean;
/**
 * @deprecated use isPositiveInt instead
 */
declare const isPositive: (arg: any) => boolean;
declare const isPositiveInt: (arg: any) => boolean;
/**
 * @deprecated use isNegativeInt instead
 */
declare const isNegative: (arg: any) => boolean;
declare const isNegativeInt: (arg: any) => boolean;
declare const isNumber: (arg: any) => arg is number;
declare const isBigInt: (arg: any) => arg is BigInt;
declare const isBigIntString: (arg: string) => boolean;
declare const isOutsideInt4: (num: number) => boolean;

/**
 *
 * @example isNumeric(1) => true
 * @example isNumeric(10e8) => true
 * @example isNumeric('1') => true
 * @example isNumeric('1.1') => true
 * @example isNumeric('1.1.1') => false
 * @example isNumeric('1-1') => false
 */
declare const isNumeric: (arg: number | string) => boolean;

declare const isNumericId: (id: string) => boolean;

declare const isObject: <T>(arg?: any) => arg is PlainObject<T>;

declare const isPastDate: (arg: DateLike) => boolean;

declare const isPromise: (arg: any) => boolean;

declare const isPWA: () => boolean;

declare const isReactElement: (value: any) => boolean;

declare const isRegExp: (arg: any) => arg is RegExp;

declare const isSame: (value1: any, value2: any) => boolean;

/**
 * Check if an array of numbers is a sequence
 * @example
 *  [1,2,3] = true
 *  [0,1,2] = false (starts at 0) TODO: add option to start from different number
 *  [1,3,4] = false (the sequence is not continuous, has gaps)
 *  [1,1,2] = false (has repeated values)
 */
declare const isSequence: (numbers: number[]) => boolean;

declare const isServer: () => boolean;

declare const isSpacedString: (s: string) => boolean;

declare const isString: (arg: any) => arg is string;

declare const isStringDate: (arg: string) => boolean;

declare const isURL: (arg: string) => boolean;

declare const isUUID: (arg: string) => boolean;

declare const isValue: <T>(arg?: Maybe<T>) => arg is T;

export { BoolMap, Coords, DateLike, DateRange, DateSeries, Datey, Defined, Dimensions, HashMap, ISODate, ISODay, ISOMonth, ISOYear, JS_MAX_DIGITS, Key, Matrix, Maybe, MaybePromise, MaybePromiseOrValue, MaybePromiseOrValueArray, NonUndefined, NumberMap, ObjectEntries, ObjectEntry, ObjectKey, ObjectKeys, ObjectValue, ObjectValues, PickDefined, PickRequired, PlainKey, PlainObject, Point, PrismaSelect, Serialized, StringMap, Timezone, TrueMap, VoidFn, array, arrayDiff, arrayIntersection, average, capitalize, chunkArray, chunkedAll, chunkedAsync, chunkedDynamic, clamp, cleanSpaces, cyclicalItem, dir, enumKeys, enumValues, filterAlphanumeric, first, firstKey, firstValue, formatCamelCase, formatCookies, formatIndexProgress, formatNumber, formatPercentage, formatProgress, formatTrpcInputQueryString, getCookieByName, getDateRangeSeries, getDateSeries, getDateSeriesRange, getKeys, getUrlSearchParam, getUrlSearchParams, groupByKey, incrementalId, isArray, isArrayIncluded, isBetween, isBigInt, isBigIntString, isBoolean, isBrowser, isBuffer, isClient, isEmail, isEmpty, isEmptyArray, isEmptyObject, isEmptyString, isEven, isFile, isFunction, isFutureDate, isInt, isJsDate, isKey, isLastIndex, isNegative, isNegativeInt, isNotEmptyString, isNumber, isNumeric, isNumericId, isObject, isOdd, isOutside, isOutsideInt4, isOver18, isPWA, isPastDate, isPositive, isPositiveInt, isPromise, isReactElement, isRegExp, isSame, isSequence, isServer, isSpacedString, isStrictlyBetween, isString, isStringDate, isURL, isUUID, isValue, keysLength, last, lastIndex, mapByKey, max, merge, mergeArrays, min, moveToFirst, moveToLast, multiply, noop, normaliseArray, normaliseNumber, normalizeNumber, objectDiff, omit, parseDate, percentageChange, pickObjectKeys, pickObjectValues, pluck, prismaDateRange, promiseWithTimeout, randomAddress, randomAlphaNumericCode, randomArray, randomArrayItem, randomBankAccount, randomBigInt, randomBool, randomChar, randomCompany, randomCoords, randomDate, randomDateRange, randomEmail, randomEmoji, randomEmptyValue, randomEnumKey, randomEnumValue, randomFile, randomFirstName, randomFloat, randomFormattedPercentage, randomFullName, randomFutureDate, randomHandle, randomHexColor, randomHexValue, randomHtmlColorName, randomIBAN, randomIP, randomInt, randomLastName, randomLat, randomLng, randomMaxDate, randomMaxInt, randomMaxSafeInt, randomName, randomNegativeInt, randomNoun, randomNumericCode, randomObject, randomParagraph, randomPassword, randomPastDate, randomPath, randomPhoneNumber, randomPositiveInt, randomString, randomSymbol, randomUUID, randomValue, randomVerb, randomWord, removeUndefinedValues, scrambleText, serialize, seriesAsync, setObjectPath, setUrlSearchParams, shuffle, sleep, startOfDay, startOfNextMonth, startOfNextWeek, startOfThisWeek, startOfToday, startOfTomorrow, startOfUTCDay, startOfUTCTomorrow, stringToCSSUnicode, stringToUnicode, stringify, sum, toggleArray, toggleArrayValue, truncate, uniqueValues };
